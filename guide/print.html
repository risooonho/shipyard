<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shipyard User's Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="welcome.html">Welcome</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="fundamentals.html"><strong aria-hidden="true">2.</strong> Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/world.html"><strong aria-hidden="true">2.1.</strong> Create a World</a></li><li class="chapter-item expanded "><a href="fundamentals/run.html"><strong aria-hidden="true">2.2.</strong> Run the World</a></li><li class="chapter-item expanded "><a href="fundamentals/add-entities.html"><strong aria-hidden="true">2.3.</strong> Add Entities</a></li><li class="chapter-item expanded "><a href="fundamentals/delete-entities.html"><strong aria-hidden="true">2.4.</strong> Delete Entities</a></li><li class="chapter-item expanded "><a href="fundamentals/add-components.html"><strong aria-hidden="true">2.5.</strong> Add Components</a></li><li class="chapter-item expanded "><a href="fundamentals/remove-components.html"><strong aria-hidden="true">2.6.</strong> Remove Components</a></li><li class="chapter-item expanded "><a href="fundamentals/delete-components.html"><strong aria-hidden="true">2.7.</strong> Delete Components</a></li><li class="chapter-item expanded "><a href="fundamentals/get-and-modify.html"><strong aria-hidden="true">2.8.</strong> Get and Modify Components</a></li><li class="chapter-item expanded "><a href="fundamentals/iterators.html"><strong aria-hidden="true">2.9.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="fundamentals/systems.html"><strong aria-hidden="true">2.10.</strong> Systems</a></li></ol></li><li class="chapter-item expanded "><a href="going-further.html"><strong aria-hidden="true">3.</strong> Going Further</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="going-further/world-insides.html"><strong aria-hidden="true">3.1.</strong> What's inside a World?</a></li><li class="chapter-item expanded "><a href="going-further/parallelism.html"><strong aria-hidden="true">3.2.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="going-further/packs.html"><strong aria-hidden="true">3.3.</strong> Packs</a></li><li class="chapter-item expanded "><a href="going-further/other-component-storage.html"><strong aria-hidden="true">3.4.</strong> Other Components and Storages</a></li><li class="chapter-item expanded "><a href="going-further/try-unchecked.html"><strong aria-hidden="true">3.5.</strong> Might want to try_ or go _unchecked</a></li><li class="chapter-item expanded "><a href="going-further/syntactic-peculiarities.html"><strong aria-hidden="true">3.6.</strong> Syntactic Peculiarities</a></li></ol></li><li class="chapter-item expanded "><a href="recipes.html"><strong aria-hidden="true">4.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recipes/hierarchy.html"><strong aria-hidden="true">4.1.</strong> Hierarchy</a></li><li class="chapter-item expanded "><a href="recipes/seed.html"><strong aria-hidden="true">4.2.</strong> Seed</a></li><li class="chapter-item expanded "><a href="recipes/0.4-migration.html"><strong aria-hidden="true">4.3.</strong> 0.4 migration</a></li></ol></li><li class="chapter-item expanded "><a href="pilgrimage.html"><strong aria-hidden="true">5.</strong> Pilgrimage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pilgrimage/different-types-of-ecs.html"><strong aria-hidden="true">5.1.</strong> Different Types of ECS</a></li><li class="chapter-item expanded "><a href="pilgrimage/more-resources.html"><strong aria-hidden="true">5.2.</strong> More Resources</a></li></ol></li><li class="chapter-item expanded "><a href="contributors.html"><strong aria-hidden="true">6.</strong> Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Shipyard User's Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome-to-shipyard" id="welcome-to-shipyard">Welcome to Shipyard!</a></h1>
<p><a href="https://github.com/leudz/shipyard">Shipyard</a> is an Entity Component System focused on usability and speed. An ECS is a great way to organize logic and data.</p>
<p>There are two main benefits to using an ECS:</p>
<ol>
<li>Elegant approach for humans
<ul>
<li>Composition over inheritance</li>
<li>Separation of concerns</li>
<li>Less burdened by lifetimes</li>
</ul>
</li>
<li>Optimal design for computers
<ul>
<li>Spatial locality</li>
<li>Less pointer chasing</li>
</ul>
</li>
</ol>
<p>However, programming with an ECS requires thinking about data and logic in a different way than you might be used to.</p>
<h1><a class="header" href="#how-does-it-work" id="how-does-it-work">How does it work?</a></h1>
<p>Components hold data. Entities are simply ids used to refer to a group of components.</p>
<p>Systems do the heavy lifting: updating components, running side-effects, and integrating with other parts of the code.</p>
<p>To see how Shipyard differs from other ECS implementations, see <a href="./pilgrimage/different-types-of-ecs.html">Different Types of ECS</a>.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>For most target architecture you can just add it to Cargo.toml.</p>
<p>For single-threaded environments (like WASM) or embedded you'll need to turn off default features and add features back in when needed.</p>
<h1><a class="header" href="#fundamentals" id="fundamentals">Fundamentals</a></h1>
<p>Now that we're ready to use Shipyard, let's learn the basics!</p>
<h1><a class="header" href="#create-a-world" id="create-a-world">Create a World</a></h1>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> is Shipyard's core data structure: It holds all data and knows how to process systems. All operations originate from one (or more) <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>.</p>
<p>You can create a <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> by using <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.default"><code>default</code></a> or <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.new"><code>new</code></a>:</p>
<pre><code class="language-rust noplaypen">let world = World::default();
let world = World::new();
</code></pre>
<p>There is no need to register components.
A component's storage will be created when we access it. </p>
<p>Note that we didn't make <code>world</code> mutable.
That is because all of <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>'s methods take a shared reference. This makes <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> easier to use across threads.</p>
<hr />
<p>Now that we have a <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>, it would be nice to be able to do something with it.
That's what we'll see in the next chapter!</p>
<h1><a class="header" href="#run-the-world" id="run-the-world">Run the World</a></h1>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a> is one of three ways to modify components and entities.
It takes a single argument, a function or a closure and executes it:</p>
<pre><code class="language-rust noplaypen">world.run(|mut all_storages: AllStoragesViewMut| {
    // -- snip --
}).unwrap();
</code></pre>
<p>In this example we ask the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> for an <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStoragesViewMut.html"><code>AllStoragesViewMut</code></a>, which is an exclusive view over <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html"><code>AllStorages</code></a>, the storage holding all components and entities.</p>
<p>Storage accesses follow the same rules as Rust's borrowing: You can have as many shared accesses to a storage as you like or a single exclusive access.</p>
<p>When <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a> executes it will borrow all requested storages at runtime, like a <code>RwLock</code>, and return a view for each.
For any storage except <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html"><code>AllStorages</code></a> they'll also need a shared access to <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html"><code>AllStorages</code></a>.
Therefore we can't request both <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStoragesViewMut.html"><code>AllStoragesViewMut</code></a> and an additional storage.
It just wouldn't work.</p>
<p>We can work around this limitation by accessing storages through <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html"><code>AllStorages</code></a>.</p>
<pre><code class="language-rust noplaypen">world.run(|all_storages: AllStoragesViewMut| {
    // do something with all_storages

    all_storages.run(|usizes: View&lt;usize&gt;| {
        // -- snip --
    }).unwrap();
}).unwrap();
</code></pre>
<p>You can find a complete list of all views in <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a>'s <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run">documentation</a>.</p>
<hr />
<p>Thanks to <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a> we can add entities and components to the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>.
In the next section we will see how it is done.</p>
<h1><a class="header" href="#add-entities" id="add-entities">Add Entities</a></h1>
<p>To add entities we'll use <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a>, the exclusive view over the entities storage, and <a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>ViewMut</code></a>, an exclusive view over a component storage.</p>
<h3><a class="header" href="#add-an-entity-with-a-single-component" id="add-an-entity-with-a-single-component">Add an entity with a single component</a></h3>
<pre><code class="language-rust noplaypen">world.run(|mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;| {
    let _entity = entities.add_entity(&amp;mut u32s, 0);
}).unwrap();
</code></pre>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.Entities.html#method.add_entity"><code>add_entity</code></a> creates a new entity with the given component and it'll return an <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a>, the id of the newly created entity.</p>
<h3><a class="header" href="#add-an-entity-with-multiple-components" id="add-an-entity-with-multiple-components">Add an entity with multiple components</a></h3>
<p>Of course, we can also make an entity with multiple components. For that we'll just have to use tuples for both arguments:</p>
<pre><code class="language-rust noplaypen">world.run(
    |mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;, mut usize: ViewMut&lt;usize&gt;| {
        let _entity = entities.add_entity((&amp;mut u32s, &amp;mut usize), (0, 10));
    },
).unwrap();
</code></pre>
<h3><a class="header" href="#add-an-entity-with-no-components" id="add-an-entity-with-no-components">Add an entity with no components</a></h3>
<p>We can use <code>()</code> for both argument to create an empty entity and add components later.</p>
<pre><code class="language-rust noplaypen">world.run(|mut entities: EntitiesViewMut| {
    let _entity = entities.add_entity((), ());
}).unwrap();
</code></pre>
<h1><a class="header" href="#delete-entities" id="delete-entities">Delete Entities</a></h1>
<p>Deleting an entity deletes it from the entities storage, while also deleting all its components.</p>
<pre><code class="language-rust noplaypen">world.run(|mut all_storages: AllStoragesViewMut| {
    all_storages.delete_entity(entity_id);
}).unwrap();
</code></pre>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html#method.delete_entity"><code>delete</code></a> takes a single <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a> of the entity you want to delete.
The return value is a <code>bool</code> that indicates whether the entity existed in the entities storage.</p>
<h1><a class="header" href="#add-components" id="add-components">Add Components</a></h1>
<p>An entity can only have a single instance of a particular component type.<br />
Adding a second component of the same type to an entity will simply replace the existing component.</p>
<h3><a class="header" href="#add-a-single-component" id="add-a-single-component">Add a single component</a></h3>
<pre><code class="language-rust noplaypen">world.run(|entities: EntitiesView, mut u32s: ViewMut&lt;u32&gt;| {
    entities.add_component(entity_id, &amp;mut u32s, 0);
}).unwrap();
</code></pre>
<p>You'll notice that we use <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesView.html"><code>EntitiesView</code></a> and not <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a>.
The entities storage is only used to check if the <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a> is alive.
We could of course use <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a>, but exclusive access is not necessary.</p>
<p>Just like <a href="https://docs.rs/shipyard/latest/shipyard/struct.Entities.html#method.add_entity"><code>add_entity</code></a>, we pass the storage and the component value.</p>
<h3><a class="header" href="#add-multiple-components" id="add-multiple-components">Add multiple components</a></h3>
<p>We use tuples for multiple components just as with <a href="https://docs.rs/shipyard/latest/shipyard/struct.Entities.html#method.add_entity"><code>add_entity</code></a>.</p>
<pre><code class="language-rust noplaypen">world.run(
    |entities: EntitiesView, mut u32s: ViewMut&lt;u32&gt;, mut usizes: ViewMut&lt;usize&gt;| {
        entities.add_component(entity_id, (&amp;mut u32s, &amp;mut usizes), (0, 10));
    },
).unwrap();
</code></pre>
<h1><a class="header" href="#remove-components" id="remove-components">Remove Components</a></h1>
<p>For components, &quot;remove&quot; and &quot;delete&quot; have different meanings. A remove returns the component(s) being removed.  A delete doesn't return anything.</p>
<h3><a class="header" href="#remove-a-single-component" id="remove-a-single-component">Remove a single component</a></h3>
<pre><code class="language-rust noplaypen">world.run(|mut u32s: ViewMut&lt;u32&gt;| {
    let i = u32s.remove(entity_id);
}).unwrap();
</code></pre>
<p>There is no need for <code>Entities</code> here. You can call the <code>remove</code> method directly on the component storage view.</p>
<h3><a class="header" href="#remove-multiple-components" id="remove-multiple-components">Remove multiple components</a></h3>
<pre><code class="language-rust noplaypen">world.run(|mut u32s: ViewMut&lt;u32&gt;, mut usizes: ViewMut&lt;usize&gt;| {
    let (_i, _j) = (&amp;mut u32s, &amp;mut usizes).remove(entity_id);
}).unwrap();
</code></pre>
<p>We have to use the explicit syntax in this case because we could be trying to remove just <code>u32</code>. We'll see later why we'd want that.</p>
<h1><a class="header" href="#delete-components" id="delete-components">Delete Components</a></h1>
<h3><a class="header" href="#delete-a-single-component" id="delete-a-single-component">Delete a single component</a></h3>
<pre><code class="language-rust noplaypen">world.run(|mut u32s: ViewMut&lt;u32&gt;| {
    u32s.delete(entity_id);
}).unwrap();
</code></pre>
<h3><a class="header" href="#delete-multiple-components" id="delete-multiple-components">Delete multiple components</a></h3>
<pre><code class="language-rust noplaypen">world.run(|mut u32s: ViewMut&lt;u32&gt;, mut usizes: ViewMut&lt;usize&gt;| {
    (&amp;mut u32s, &amp;mut usizes).delete(entity_id);
}).unwrap();
</code></pre>
<h3><a class="header" href="#delete-all-components" id="delete-all-components">Delete all components</a></h3>
<p>Note that when you delete all components of an entity with <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html#method.strip"><code>strip</code></a>, the entity itself won't be deleted. You can attach components to it again afterwards.</p>
<pre><code class="language-rust noplaypen">world.run(|mut all_storages: AllStoragesViewMut| {
    all_storages.strip(entity_id);
}).unwrap();
</code></pre>
<h1><a class="header" href="#get-and-modify-components" id="get-and-modify-components">Get and Modify Components</a></h1>
<p>To access or update component(s) of a single entity you can use <a href="https://docs.rs/shipyard/latest/shipyard/trait.Get.html#tymethod.get"><code>get</code></a>. It'll work with both shared and unique views.</p>
<h3><a class="header" href="#update-a-single-component" id="update-a-single-component">Update a single component</a></h3>
<pre><code class="language-rust noplaypen">world.run(|mut u32s: ViewMut&lt;u32&gt;| {
    *(&amp;mut u32s).get(entity_id).unwrap() = 1;
}).unwrap();
</code></pre>
<p><a href="https://docs.rs/shipyard/latest/shipyard/trait.Get.html#tymethod.get"><code>get</code></a> will return a <code>&amp;T</code> when used with a <a href="https://docs.rs/shipyard/latest/shipyard/struct.View.html"><code>&amp;View&lt;T&gt;</code></a> and a <code>&amp;mut T</code> with a <a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>&amp;mut ViewMut&lt;T&gt;</code></a>.
You can also get a <code>&amp;T</code> from a <a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>ViewMut&lt;T&gt;</code></a>, which is why we have to explicitly get a mutable borrow on <code>u32s</code>.</p>
<p>When using a single view, if you're certain that an entity has the desired component, you can access it directly via index:</p>
<pre><code class="language-rust noplaypen">world.run(|mut u32s: ViewMut&lt;u32&gt;| {
    u32s[entity_id] = 1;
}).unwrap();
</code></pre>
<h3><a class="header" href="#update-multiple-components" id="update-multiple-components">Update multiple components</a></h3>
<p>We can mix and match shared and unique component access with <a href="https://docs.rs/shipyard/latest/shipyard/trait.Get.html#tymethod.get"><code>get</code></a>:</p>
<pre><code class="language-rust noplaypen">world.run(|mut u32s: ViewMut&lt;u32&gt;, usizes: View&lt;usize&gt;| {
    let (i, &amp;j) = (&amp;mut u32s, &amp;usizes).get(entity_id).unwrap();
    *i += j as u32;
    *i += j as u32;
}).unwrap();
</code></pre>
<h1><a class="header" href="#iterators" id="iterators">Iterators</a></h1>
<p>Iteration is one of the most important features of an ECS.</p>
<p>In Shipyard this is achieved using the <a href="https://docs.rs/shipyard/latest/shipyard/trait.IntoIter.html#tymethod.iter"><code>iter</code></a> method on views.</p>
<h3><a class="header" href="#single-component-type" id="single-component-type">Single component type</a></h3>
<p>You can use it on a single view to get one type of components:</p>
<pre><code class="language-rust noplaypen">world.run(|u32s: View&lt;u32&gt;| {
    for i in u32s.iter() {
        dbg!(i);
    }
}).unwrap();
</code></pre>
<p>This iterator is extremely fast, since all <code>u32</code> components are stored directly next to each other (which is something computers really like nowadays).</p>
<p>Unlike in the last chapter, there is no need to provide an <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a>.
On the contrary, you can ask the iterator to tell you which entity each component is attached to using <a href="https://docs.rs/shipyard/latest/shipyard/trait.Shiperator.html#method.with_id"><code>with_id</code></a>:</p>
<pre><code class="language-rust noplaypen">world.run(|u32s: View&lt;u32&gt;| {
    for (id, i) in u32s.iter().with_id() {
        println!(&quot;{} belongs to entity {:?}&quot;, i, id);
    }
}).unwrap();
</code></pre>
<h3><a class="header" href="#multiple-component-types" id="multiple-component-types">Multiple component types</a></h3>
<p>While single views are useful, multiple views are where an ECS shines:</p>
<pre><code class="language-rust noplaypen">world.run(|u32s: View&lt;u32&gt;, usizes: View&lt;usize&gt;| {
    for (i, j) in (&amp;u32s, &amp;usizes).iter() {
        // -- snip --
    }
}).unwrap();
</code></pre>
<p>The iterator will only yield components from entities that have both <code>u32</code> and <code>usize</code> components, while ignoring the rest.</p>
<p>You can use views in any order.
However, using the same combination of views in different positions might yield components in a different order.
You shouldn't expect specific ordering from Shipyard's iterators, in general.</p>
<hr />
<p>Iteration is only one of the main assets of an ECS.
In the next chapter we'll talk about perhaps the most important feature: Systems.</p>
<h1><a class="header" href="#systems" id="systems">Systems</a></h1>
<p>Systems are a great way to organize code.<br />
A function with views as arguments is all you need.</p>
<p>Here's an example:</p>
<pre><code class="language-rust noplaypen">fn create_ints(mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;) {
    // -- snip --
}
</code></pre>
<p>We have a system, let's run it!</p>
<pre><code class="language-rust noplaypen">world.run(create_ints).unwrap();
</code></pre>
<h3><a class="header" href="#passing-data-to-systems" id="passing-data-to-systems">Passing Data to Systems</a></h3>
<p>The first argument doesn't have to be a view, you can pass any data to a system. You don't even have to own it. </p>
<pre><code class="language-rust noplaypen">fn in_acid(season: &amp;Season, positions: View&lt;Position&gt;, mut healths: ViewMut&lt;Health&gt;) {
    // -- snip --
}

world.run_with_data(in_acid, &amp;season);
</code></pre>
<p>We call <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run_with_data"><code>run_with_data</code></a> instead of <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a> when we want to pass data to a system.</p>
<p>If you want to pass multiple variables, you can use a tuple.</p>
<pre><code class="language-rust noplaypen">fn in_acid(
    (season, precipitation): (&amp;Season, &amp;Precipitation),
    positions: View&lt;Position&gt;,
    mut healths: ViewMut&lt;Health&gt;,
) {
    // -- snip --
}

world.run_with_data(in_acid, (&amp;season, &amp;precipitation)).unwrap();
</code></pre>
<h3><a class="header" href="#workloads" id="workloads">Workloads</a></h3>
<p>A workload is a group of one or more systems that is assigned a name.</p>
<pre><code class="language-rust noplaypen">fn create_ints(mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;) {
    // -- snip --
}

fn delete_ints(mut u32s: ViewMut&lt;u32&gt;) {
    // -- snip --
}

Workload::builder(&quot;Int cycle&quot;)
    .with_system(&amp;create_ints)
    .with_system(&amp;delete_ints)
    .add_to_world(&amp;world)
    .unwrap();
</code></pre>
<p>As opposed to <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a>, <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.add_workload"><code>add_workload</code></a> won't execute any system until we ask it to.
Workloads are stored in the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>, ready to be run again and again.</p>
<pre><code class="language-rust noplaypen">world.run_workload(&quot;Int cycle&quot;).unwrap();
// or
world.run_default().unwrap();
</code></pre>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>run_default</code></a> will run the first workload added in the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run_default"><code>World</code></a>, or the one you choose with <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.set_default_workload"><code>set_default_workload</code></a>.</p>
<p>There's a few points to keep in mind about workloads:</p>
<ol>
<li>Workloads will run their systems first to last or at the same time when possible. We call this <em>outer-parallelism</em>, you can learn more about it in <a href="fundamentals/../going-further/parallelism.html">this chapter</a>.</li>
<li>A workload cannot be modified once it's defined. Think of it more as a one-time setup than something you do dynamically at runtime. Workloads don't take up much memory so even if you make a few with similar systems it's not a problem.</li>
</ol>
<hr />
<p>Congratulations, that's it for the fundamentals!</p>
<h1><a class="header" href="#going-further" id="going-further">Going Further</a></h1>
<p>This section covers more advanced topics. Topics include parallelism, packs, and how everything behaves so you can avoid surprises.</p>
<h1><a class="header" href="#whats-inside-a-world" id="whats-inside-a-world">What's inside a World?</a></h1>
<p>In the last section we learned how to interact with <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> and access what's inside it without knowing what it is. Let's change that!</p>
<h3><a class="header" href="#storage" id="storage">Storage</a></h3>
<p>Currently there exists only one type of storage in Shipyard: <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html"><code>SparseSet</code></a>. We're just going to focus on that implementation.</p>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html"><code>SparseSet</code></a> is a data-structure made of 3 vectors:</p>
<ul>
<li><code>sparse</code> contains indices (<code>usize</code>) to the <code>dense</code> vector</li>
<li><code>dense</code> contains indices (<a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a>) to the <code>sparse</code> vector</li>
<li><code>data</code> contains the actual components</li>
</ul>
<p>When <code>sparse</code> and <code>dense</code> point to each other, the entity owns the component present in the <code>data</code> vector at the same <code>dense</code> index.</p>
<p><code>dense</code> is always the same length as <code>data</code>, the number of components present in the storage.</p>
<p><code>sparse</code>, on the other hand, is more or less as big as the total number of entities created minus the number of entities deleted.</p>
<p>Let's look at an example:</p>
<pre><code class="language-rust noplaypen">let world = World::new();

world.run(
    |mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;, mut f32s: ViewMut&lt;f32&gt;| {
        let _entity0 = entities.add_entity(&amp;mut u32s, 10);
        let _entity1 = entities.add_entity(&amp;mut f32s, 20.0);
        let _entity2 = entities.add_entity(&amp;mut u32s, 30);
    },
).unwrap();
</code></pre>
<p>When we create the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> there is no component storage in it, <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html#method.run"><code>run</code></a> will create an empty storage for <code>u32</code> and <code>f32</code>.
We then create <code>entity0</code>, <code>u32</code>'s storage now looks like this:</p>
<pre><code>sparse: [0]
dense: [0]
data: [10]
</code></pre>
<p><code>sparse[0]</code> and <code>dense[0]</code> point to each other, the entity owns a component in this storage.
We add two more entities, now <code>u32</code> looks like this:</p>
<pre><code>sparse: [0, 0, 1]
dense: [0, 2]
data: [10, 30]
</code></pre>
<p>We can see that <code>sparse[1]</code> got initialized with <code>0</code>, <code>entity1</code> doesn't have any <code>u32</code> component and <code>dense[0]</code> doesn't point back to it, all good.</p>
<h3><a class="header" href="#entities" id="entities">Entities</a></h3>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.Entities.html"><code>Entities</code></a> is a simpler data structure, it's made of an <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a> vector and an optional tuple of two indices. This tuple points to the first and last deleted entity.</p>
<p>Each time an entity is added, the tuple is checked. If it is <code>None</code>, then the entity is allocated at the end of the vector.</p>
<p>If the tuple is <code>Some</code>, we'll use the oldest deleted index for the new entity and update the tuple.</p>
<p>If <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a> was interpreted as only an index, then two entities could have the same id. In just few operations, add - remove - add, we're back to the same index for a different entity, which could cause problems.</p>
<p>Which is why <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a> is not just an index, it is interpreted as two parts: a 48-bit index and a 16-bit generation.</p>
<p>When we delete an entity its generation gets incremented and its index becomes part of the optional tuple.</p>
<p>This tuple only contains two elements, however, so we use the indices of deleted <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a> entries to to form a linked list of all the deleted entries from most recently deleted to oldest.</p>
<p>Let's modify our previous example a little:</p>
<pre><code class="language-rust noplaypen">let world = World::new();

let [entity0, entity1] = world.run(
    |mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;, mut f32s: ViewMut&lt;f32&gt;| {
        let result = [
            entities.add_entity(&amp;mut u32s, 10),
            entities.add_entity(&amp;mut f32s, 20.0),
        ];
        let _entity2 = entities.add_entity(&amp;mut u32s, 30);

        result
    },
).unwrap();

world.run(|mut all_storages: AllStoragesViewMut| {
    all_storages.delete_entity(entity0);
    all_storages.delete_entity(entity1);
}).unwrap();
</code></pre>
<p>Let's take a look at what happens to <a href="https://docs.rs/shipyard/latest/shipyard/struct.Entities.html"><code>Entities</code></a> as we run this code.  After adding all three entries, it looks something like this:</p>
<pre><code>ids: [
    { index: 0, gen: 0 },
    { index: 1, gen: 0 },
    { index: 2, gen: 0 }
]
deleted: None
</code></pre>
<p>Then we delete <code>entity0</code>. Since there is just a single deleted entity, it's both the most recent one and the oldest one in the tuple.</p>
<pre><code>ids: [
    { index: 0, gen: 1 },
    { index: 1, gen: 0 },
    { index: 2, gen: 0 }
]
deleted: Some((0, 0))
</code></pre>
<p>Finally, we delete <code>entity1</code>.  <code>ids[newest].index</code> becomes <code>1</code> and we have a linked list where we start at the oldest index <code>0</code>.  <code>0</code> is not the newest index, so we know value <code>1</code> is the index of the next deleted <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a>.  <code>1</code> is the newest index, so we know we have reached the end of the linked list of deleted entries.</p>
<pre><code>ids: [
    { index: 1, gen: 1 },
    { index: 1, gen: 1 },
    { index: 2, gen: 0 }
]
deleted: Some((1, 0))
</code></pre>
<h3><a class="header" href="#entityid" id="entityid">EntityId</a></h3>
<p>While only 64 bits, <a href="https://docs.rs/shipyard/latest/shipyard/struct.EntityId.html"><code>EntityId</code></a>s are very interesting. Almost all ECS have this kind of id, the difference being the length of the id and generation.</p>
<p>32 bits felt too small to fit the wildest use cases. A generic approach was discarded due to: first - adding a generic everywhere, and second - making actions between worlds more difficult.</p>
<p>In some ECS implementations generations sometimes take more space, because who needs 48 bits for the index? But at the same time, who needs more than 16 bits for the generation?</p>
<p>In the exceptional event that you add and remove entities to and from the same index enough times to reach the generation limit, the <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> won't panic. This index will be considered dead (simply by not adding it the linked list) and you'll get an entity at another index.</p>
<p>Plus, we add and delete from opposite sides of the linked list making the generation increase slower in general.</p>
<hr />
<p>In the next chapter we'll look into parallelism.</p>
<h1><a class="header" href="#parallelism" id="parallelism">Parallelism</a></h1>
<p>By late 90s - early 2000s, CPUs started to get too close to the physical limitation of transistors and manufacturers couldn't &quot;just&quot; make their product faster. The solution: more cores.</p>
<p>Nowadays almost all devices come with multiple cores, it would be a shame to use just one.</p>
<p>In ECS there's two big ways to split work across cores: running systems on separate threads or using a parallel iterator, we call these two methods &quot;outer-parallelism&quot; and &quot;inner-parallelism,&quot; respectively.</p>
<h3><a class="header" href="#outer-parallelism" id="outer-parallelism">Outer-parallelism</a></h3>
<p>We'll start by the most simple one to use. So simple that there's nothing to do, workloads handle all the work for you. We even almost used multiple threads in the <a href="going-further/../fundamentals/systems.html">Systems chapter</a>.</p>
<p>As long as the &quot;parallel&quot; feature is set (it's enabled by default), workloads will try to execute systems as much in parallel as possible. There is a set of rules that defines the &quot;possible&quot;:</p>
<ul>
<li>Systems accessing <a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStorages.html"><code>AllStorages</code></a> stop all multithreading (this is a limit of the current implementation and will be relaxed a little in the future)</li>
<li>There can't be any other access during an exclusive access, so <a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>ViewMut&lt;T&gt;</code></a> will block <code>T</code> threading</li>
</ul>
<p>When you make a workload, all systems in it will be checked and batches (groups of systems that don't conflict) will be created.</p>
<p>There's just one problem with this approach. What happens when I want to force two non-conflicting systems to run one after the other? The <a href="https://docs.rs/shipyard/latest/shipyard/struct.FakeBorrow.html"><code>FakeBorrow</code></a> system is here just for that, it'll mimic a system accessing the storage exclusively without actually doing it. To use it, place it in-between your other systems in a workload like this:</p>
<pre><code class="language-rust noplaypen">fn display_first(u32s: View&lt;u32&gt;) {
    // -- snip --
}

fn display_next(u32s: View&lt;u32&gt;) {
    // -- snip --
}

world
    .add_workload(&quot;Display&quot;)
    .with_system(system!(display_first))
    .with_system(system!(|_: FakeBorrow&lt;usize&gt;| {}))
    .with_system(system!(display_next))
    .build();
</code></pre>
<h3><a class="header" href="#inner-parallelism" id="inner-parallelism">Inner-parallelism</a></h3>
<p>While parallel iterators does require us to modify our code, it's just a matter or adding <code>par_</code> to <code>iter</code>.
Don't forget to import rayon. <a href="https://docs.rs/shipyard/latest/shipyard/trait.IntoIter.html#tymethod.par_iter"><code>par_iter</code></a> will return a <a href="https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html"><code>ParallelIterator</code></a>.</p>
<p>Example:</p>
<pre><code class="language-rust noplaypen">use rayon::prelude::*;

fn many_u32s(mut u32s: ViewMut&lt;u32&gt;) {
    u32s.par_iter().for_each(|i| {
        // -- snip --
    });
}
</code></pre>
<p>Don't replace all your <a href="https://docs.rs/shipyard/latest/shipyard/trait.IntoIter.html#tymethod.iter"><code>iter</code></a> method calls just yet, however! Using a parallel iterator comes with an upfront overhead cost. It will only exceed the speed of its sequential counterpart on storages large enough to make up for the overhead cost in improved processing efficiency.</p>
<hr />
<p>In the next chapter we'll see how packs leverage <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html"><code>SparseSet</code></a> to add functionality and/or gain performance.</p>
<h1><a class="header" href="#packs" id="packs">Packs</a></h1>
<p>/!\ Tight and loose packs are currently unavailable. They will be back.</p>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html"><code>SparseSet</code></a>s are very flexible, so much so that we can use their internal layout to encode additional information.</p>
<p>Quick overview compared to non packed storage:</p>
<table><thead><tr><th align="center"></th><th align="center">Tight</th><th align="center">Loose</th><th align="center">Free</th><th align="center">Update</th></tr></thead><tbody>
<tr><td align="center">Iteration speed</td><td align="center">++</td><td align="center">+</td><td align="center">+</td><td align="center">-</td></tr>
<tr><td align="center">Add/Remove speed</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr>
<tr><td align="center">Memory</td><td align="center">same</td><td align="center">same</td><td align="center">+</td><td align="center">same</td></tr>
<tr><td align="center">Special</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">tracks insertion / modification / deletion</td></tr>
</tbody></table>
<h3><a class="header" href="#tight" id="tight">Tight</a></h3>
<p>Let's start with the one offering the most performance, so good your CPU will stop taking so many vacations.</p>
<p>Tight pack moves components of an entity that contains all components in the pack to the front of the <code>data</code> vector. The nice thing is: a single storage contains all components of this type so it's always tightly packed.</p>
<p>To tightly pack multiple storages we use the <a href="https://docs.rs/shipyard/latest/shipyard/trait.TightPack.html#tymethod.tight_pack"><code>tight_pack</code></a> method on multiple views.</p>
<p>Let's go through an example:</p>
<pre><code class="language-rust noplaypen">let world = World::new();

world.run(
    |mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;, mut usizes: ViewMut&lt;usize&gt;| {
        (&amp;mut usizes, &amp;mut u32s).tight_pack();

        let entity0 = entities.add_entity(&amp;mut usizes, 0);
        let entity1 = entities.add_entity((&amp;mut usizes, &amp;mut u32s), (1, 11));
    },
);
</code></pre>
<p>After adding <code>entity0</code>, <code>usize</code>'s storage looks like this (generation omitted):</p>
<pre><code>sparse: [0]
dense: [0]
data: [0]
</code></pre>
<p>Let's add <code>entity1</code>:</p>
<pre><code>sparse: [1, 0]
dense: [1, 0]
data: [1, 0]
</code></pre>
<p>We still have <code>sparse</code> and <code>dense</code> looking at each other and <code>entity1</code> has its component at index <code>0</code> since it contains both <code>usize</code> and <code>u32</code> as opposed to <code>entity0</code>.</p>
<p>This is very powerful because when we iterate <code>usize</code> and <code>u32</code> we don't have to check anything. We know all entities matching these components are in the range <code>0..=last_packed</code>.</p>
<p>There's also one more advantage, we can iterate over chunks of these components with <a href="https://docs.rs/shipyard/latest/shipyard/iterators/struct.Tight2.html#method.into_chunk"><code>into_chunk</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/iterators/struct.Tight2.html#method.into_chunk_exact"><code>into_chunk_exact</code></a>.</p>
<p>The big downside is we have to access and pass all packed storages when doing any action on the storages that might affect the order. Adding/removing or deleting components for example. This is also the reason <a href="https://docs.rs/shipyard/latest/shipyard/trait.Remove.html"><code>Remove</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/trait.Delete.html"><code>Delete</code></a> look so bad.</p>
<h3><a class="header" href="#loose" id="loose">Loose</a></h3>
<p>Packs comes with one more limitation: we can't pack multiple times the same storage (<a href="https://github.com/leudz/shipyard/issues/47">for now</a>).</p>
<p>Loose pack let us pack again a tightly packed storage or just pack two storages without shuffling one of them.</p>
<p>This time we'll need the storages we want to pack, the other storages and call <a href="https://docs.rs/shipyard/latest/shipyard/trait.LoosePack.html#tymethod.loose_pack"><code>loose_pack</code></a>.</p>
<p><a href="https://docs.rs/shipyard/latest/shipyard/trait.LoosePack.html#tymethod.loose_pack"><code>loose_pack</code></a> needs all storages present in the pack (like <a href="https://docs.rs/shipyard/latest/shipyard/trait.TightPack.html#tymethod.tight_pack"><code>tight_pack</code></a>) but also that we specify which storages are going to be modified and which ones won't.</p>
<p>Here we pack <code>usize</code>'s storage while <code>u32</code> isn't affected:</p>
<pre><code class="language-rust noplaypen">let world = World::new();

world.run(
    |mut entities: EntitiesViewMut, mut u32s: ViewMut&lt;u32&gt;, mut usizes: ViewMut&lt;usize&gt;| {
        // usize's storage will be modified
        LoosePack::&lt;(usize,)&gt;::loose_pack((&amp;mut usizes, &amp;mut u32s));

        let entity0 = entities.add_entity(&amp;mut usizes, 0);
        let entity1 = entities.add_entity((&amp;mut usizes, &amp;mut u32s), (1, 11));
    },
);
</code></pre>
<p>After both entities have been added this is what <code>usize</code>'s storage look like:</p>
<pre><code>sparse: [1, 0]
dense: [1, 0]
data: [1, 0]
</code></pre>
<p>While the iteration speed isn't as good as tight pack, it's still better than no pack at all.</p>
<h3><a class="header" href="#update" id="update">Update</a></h3>
<p>This pack doesn't increase iteration speed but rather slows it down. That's not its purpose however, it records which components have been <em>inserted</em>, <em>modified</em> and <em>deleted</em>.</p>
<p>To get these functionalities, use <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.update_pack"><code>update_pack</code></a> on a single storage.</p>
<p>The storage will start recording <em>inserted</em> components, we can then access them with <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.inserted"><code>inserted</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.inserted_mut"><code>inserted_mut</code></a>. Note that mutating a component in the <em>inserted</em> section won't put it in the <em>modified</em> section. To move the <em>inserted</em> components we have to call <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.clear_inserted"><code>clear_inserted</code></a>, this will move them in the <em>neutral</em> section.</p>
<p><em>Modified</em> components can be accessed with <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.modified"><code>modified</code></a>/<a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.modified_mut"><code>modified_mut</code></a> and cleared with <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.clear_modified"><code>clear_modified</code></a>. <em>modified</em> is a bit misleading, components are flagged as soon as they're mutably accessed.</p>
<p>Be careful, removed components won't be recorded, only <em>deleted</em> ones. They can be accessed with <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.deleted"><code>deleted</code></a>, it contains both the components and the id of the entity they belonged to.</p>
<p>We also can take ownership of these deleted components with <a href="https://docs.rs/shipyard/latest/shipyard/struct.SparseSet.html#method.take_deleted"><code>take_deleted</code></a>.</p>
<h3><a class="header" href="#free" id="free">Free</a></h3>
<p>Free pack isn't implemented yet (<a href="https://github.com/leudz/shipyard/issues/56">#56</a>), it'll use an external vector to keep track of which entities have the required storages, speeding up iteration while not reordering any storage.</p>
<hr />
<p>In the next chapter we'll look into <code>!Send</code>/<code>!Sync</code> components and unique storage.</p>
<h1><a class="header" href="#other-components-and-storages" id="other-components-and-storages">Other Components and Storages</a></h1>
<p>So far we've only seen how to interact with <code>Send + Sync</code> components using the default storage, that's not always what we need.</p>
<h3><a class="header" href="#send-and-sync-components" id="send-and-sync-components"><code>!Send</code> and <code>!Sync</code> Components</a></h3>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a> can store <code>!Send</code> and/or <code>!Sync</code> components once the corresponding feature is set but they come with limitations:</p>
<ul>
<li><code>!Send</code> storages can only be added in <a href="https://docs.rs/shipyard/latest/shipyard/struct.World.html"><code>World</code></a>'s thread.</li>
<li><code>Send + !Sync</code> components can only be accessed from one thread at a time.</li>
<li><code>!Send + Sync</code> components can only be accessed immutably from other threads.</li>
<li><code>!Send + !Sync</code> components can only be accessed in the thread they were added in.</li>
</ul>
<p>These storages are accessed with <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend</code></a>, <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSync.html"><code>NonSync</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSendSync.html"><code>NonSendSync</code></a>, for example:</p>
<pre><code class="language-rust noplaypen">fn run(rcs: NonSendSync&lt;View&lt;Rc&lt;usize&gt;&gt;&gt;) {}
</code></pre>
<h3><a class="header" href="#unique-storages" id="unique-storages">Unique Storages</a></h3>
<p>When we know there'll only ever be exactly one instance of some component, it doesn't need to be attached to an entity. It also works well as global data while still being safe.</p>
<p>As opposed to other storages, unique storages have to be initialized with <code>add_unique</code>. This will both create the storage and initialize its only component. We can then access this component with <a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueView.html"><code>UniqueView</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueViewMut.html"><code>UniqueViewMut</code></a>.</p>
<pre><code class="language-rust noplaypen">let world = World::new();

world.add_unique(Camera::new());

world.run(|camera: UniqueView&lt;Camera&gt;| {
    // -- snip --
})
</code></pre>
<p>Note that <code>!Send</code>/<code>!Sync</code> components can be stored in unique storages.</p>
<h3><a class="header" href="#tag-components" id="tag-components">Tag Components</a></h3>
<p>Components don't always need data, they're sometimes just there to flag entities. We can use empty structs to take care of this job.<br />
Example:</p>
<pre><code class="language-rust noplaypen">struct Dirty;

fn flag_dirty(mut dirties: ViewMut&lt;Dirty&gt;) {
    // -- snip --
}
</code></pre>
<h1><a class="header" href="#might-want-to-try_-or-go-_unchecked" id="might-want-to-try_-or-go-_unchecked">Might want to try_ or go _unchecked</a></h1>
<p>These two are a prefix and a suffix respectively.</p>
<h3><a class="header" href="#unchecked" id="unchecked">Unchecked</a></h3>
<p>Some functions come with an <code>_unchecked</code> version. They might be memory unsafe and marked as such or &quot;just&quot; logically unsafe, in this case using it in the wrong conditions will result in unexpected behavior but won't cause Undefined Behavior.</p>
<p>Currently the only function of this kind is <a href="https://docs.rs/shipyard/latest/shipyard/struct.Entities.html#method.delete_unchecked"><code>Entities::delete_unchecked</code></a> but others will likely join it, like <a href="https://github.com/leudz/shipyard/issues/50"><code>add_component_unchecked</code></a>.</p>
<h3><a class="header" href="#try" id="try">Try</a></h3>
<p>All functions provided by shipyard should either not fail in any circumstances or have a <code>try_</code> alternative. If it isn't the case, please open an issue or PR.</p>
<h1><a class="header" href="#syntactic-peculiarities" id="syntactic-peculiarities">Syntactic Peculiarities</a></h1>
<p>Some parts of Rust are less-used than others, let's look into some of them.</p>
<h3><a class="header" href="#tuples" id="tuples">Tuples</a></h3>
<p>Shipyard uses tuples a lot, sometimes even for a single element. There are two main reasons:</p>
<ul>
<li>the elements could be any type including a tuple, for example <a href="https://docs.rs/shipyard/latest/shipyard/trait.LoosePack.html#tymethod.loose_pack"><code>loose_pack</code></a>. If <code>T</code> was allowed as input type then <code>T</code> could be <code>(usize, u32)</code>, that's not what we want though, we want them to be two different elements.</li>
<li>the compiler can't read our mind (yet), for example <a href="https://docs.rs/shipyard/latest/shipyard/trait.Remove.html#tymethod.remove"><code>remove</code></a>. <a href="https://docs.rs/shipyard/latest/shipyard/trait.Remove.html"><code>Remove</code></a> is implemented for up to ten storages but we can <a href="https://docs.rs/shipyard/latest/shipyard/trait.Remove.html#tymethod.remove"><code>remove</code></a> up to the number of storages we passed. We might have to pass 5 storages to the function because they are packed but only want to <a href="https://docs.rs/shipyard/latest/shipyard/trait.Remove.html#tymethod.remove"><code>remove</code></a> from 2.</li>
</ul>
<h3><a class="header" href="#ref-mut" id="ref-mut"><code>ref mut</code></a></h3>
<p>Some functions, like <a href="https://docs.rs/shipyard/latest/shipyard/trait.Get.html#tymethod.get"><code>get</code></a>, can return an immutable or mutable result based on which reference you use and default to immutable if you don't specify.<br />
Let's look at an example:</p>
<pre><code class="language-rust noplaypen">fn ref_mut(mut u32s: ViewMut&lt;u32&gt;) {
    let i: &amp;u32 = u32s.get(id).unwrap();
}
</code></pre>
<p>We can force the compiler to give us a <code>&amp;mut u32</code> with a few methods, one of them is to use <code>ref mut</code>:</p>
<pre><code class="language-rust noplaypen">fn ref_mut(ref mut u32s: ViewMut&lt;u32&gt;) {
    let i: &amp;mut u32 = u32s.get(id).unwrap();
}
</code></pre>
<h3><a class="header" href="#ref" id="ref"><code>ref</code></a></h3>
<p>Since Rust will default to immutable return by default, we don't have to use <code>ref</code> for the same reason as <code>ref mut</code> but we can use it for something else:</p>
<pre><code class="language-rust noplaypen">fn ref_sys(u32s: View&lt;u32&gt;, usizes: View&lt;usize&gt;) {
    (usizes, u32s).get(id).unwrap();
}
</code></pre>
<p>This example doesn't compile since <code>get</code> has to use references. We could take the views by reference at each call of course but when we'd have a bunch of them:</p>
<pre><code class="language-rust noplaypen">fn ref_sys(u32s: View&lt;u32&gt;, usizes: View&lt;usize&gt;) {
    (&amp;usizes, &amp;u32s).get(id).unwrap();
    (&amp;usizes, &amp;u32s).get(id).unwrap();
    (&amp;usizes, &amp;u32s).get(id).unwrap();
    (&amp;usizes, &amp;u32s).get(id).unwrap();
}
</code></pre>
<p>It can be easier to just use <code>ref</code>:</p>
<pre><code class="language-rust noplaypen">fn ref_sys(ref u32s: View&lt;u32&gt;, ref usizes: View&lt;usize&gt;) {
    (usizes, u32s).get(id).unwrap();
    (usizes, u32s).get(id).unwrap();
    (usizes, u32s).get(id).unwrap();
    (usizes, u32s).get(id).unwrap();
}
</code></pre>
<h1><a class="header" href="#recipes" id="recipes">Recipes</a></h1>
<p>Cool patterns you may be interested in.</p>
<h1><a class="header" href="#building-an-entity-hierarchy-with-shipyard" id="building-an-entity-hierarchy-with-shipyard">Building an Entity Hierarchy with Shipyard</a></h1>
<p>Hierarchies are a very commonly used organizational structure in game development. An important example is a transform hierarchy: child entities move along with their parents.</p>
<p>How can we build such a hierarchy of entities in shipyard?</p>
<p>One method is to use a secondary data structure which represents the hierarchy.</p>
<p>But an ECS already has all the means to store data: components. So let's use them!</p>
<p>Below you won't find a ready-to-use solution, rather some hints on how to start with your own hierarchy implementation, tailored to your requirements.</p>
<h2><a class="header" href="#parents-and-children" id="parents-and-children">Parents and Children</a></h2>
<p>Think about the different roles an entity can take in a hierarchy. It can be:</p>
<ul>
<li>a parent (root node),</li>
<li>a parent and a child (intermediate node),</li>
<li>a child (leaf node).</li>
</ul>
<p>From this we can derive two simple, composable component types:</p>
<p>A <code>Parent</code> component stores the number of its children and the first child:</p>
<pre><code class="language-rust noplaypen">struct Parent {
    num_children: usize,
    first_child: EntityId,
}
</code></pre>
<p>A <code>Child</code> component links to its parent as well as neighbor siblings:</p>
<pre><code class="language-rust noplaypen">struct Child {
    parent: EntityId,
    prev: EntityId,
    next: EntityId,
}
</code></pre>
<p>As you can see, we simply store <code>EntityId</code>s to refer to other entities inside a component.</p>
<p>Note that <code>Option</code>s are completely avoided by making the sibling chain circular:</p>
<ul>
<li>Last child's <code>next</code> points to the first child.</li>
<li>First child's <code>prev</code> points to the last child.</li>
</ul>
<p>Our entire hierarchy structure resides only in <code>Parent</code> and <code>Child</code> components  nice!</p>
<p>But it'd be a hassle to create them manually each time you want to insert an entity into the tree.</p>
<h2><a class="header" href="#lets-make-it-convenient" id="lets-make-it-convenient">Let's make it convenient</a></h2>
<p>We begin with two useful methods in a trait declaration:</p>
<pre><code class="language-rust noplaypen">trait Hierarchy {
    // Removes the child status of an entity.
    fn detach(&amp;mut self, id: EntityId);

    // Attaches an entity as a child to a given parent entity.
    fn attach(&amp;mut self, id: EntityId, parent: EntityId);
}
</code></pre>
<p>With these, you'll be able to not only insert new entities into the tree but also move a whole subtree  a child with all its descendants  to another parent.</p>
<p>Since we need access to <code>EntitiesViewMut</code> as well as our hierarchy component storages, we implement the <code>Hierarchy</code> trait for the type <code>(EntitiesViewMut&lt;'_&gt;, ViewMut&lt;'_, Parent&gt;, ViewMut&lt;'_, Child&gt;)</code>.</p>
<pre><code class="language-rust noplaypen">fn detach(&amp;mut self, id: EntityId) {
    let (_, parents, children) = self;
    // remove the Child component - if nonexistent, do nothing
    if let Some(child) = children.remove(id) {
        // retrieve and update Parent component from ancestor
        let parent = &amp;mut parents[child.parent];
        parent.num_children -= 1;

        if parent.num_children == 0 {
            // if the number of children is zero, the Parent component must be removed
            parents.remove(child.parent);
        } else {
            // the ancestor still has children, and we have to change some linking
            // check if we have to change first_child
            if parent.first_child == id {
                parent.first_child = child.next;
            }
            // remove the detached child from the sibling chain
            children[child.prev].next = child.next;
            children[child.next].prev = child.prev;
        }
    }
}
</code></pre>
<p>Before we move on to <code>attach</code>, let's make some observations.</p>
<p>We use indexing on <code>parents</code> and <code>children</code> but if the entity doesn't have the component it'll <code>unwrap</code>.</p>
<p>We don't have to worry as long as we only use the methods in our <code>Hierarchy</code> trait.</p>
<p>If you accidentally delete hierarchy components in other places without changing the linking, things will go fatally wrong. If you want to catch these errors you might want to use <code>get</code> and handle the error (for example with <code>expect</code>).</p>
<p><code>attach</code> looks like this:</p>
<pre><code class="language-rust noplaypen">fn attach(&amp;mut self, id: EntityId, parent: EntityId) {
    // the entity we want to attach might already be attached to another parent
    self.detach(id);

    let (entities, parents, children) = self;

    // either the designated parent already has a Parent component  and thus one or more children
    if let Ok(p) = parents.get(parent) {
        // increase the parent's children counter
        p.num_children += 1;

        // get the ids of the new previous and next siblings of our new child
        let prev = children[p.first_child].prev;
        let next = p.first_child;

        // change the linking
        children[prev].next = id;
        children[next].prev = id;

        // add the Child component to the new entity
        entities.add_component(id, children, Child { parent, prev, next });
    } else {
        // in this case our designated parent is missing a Parent component
        // we don't need to change any links, just insert both components
        entities.add_component(
            id,
            children,
            Child {
                parent,
                prev: id,
                next: id,
            },
        );
        entities.add_component(
            parent,
            parents,
            Parent {
                num_children: 1,
                first_child: id,
            },
        );
    }
}
</code></pre>
<p>We can now add another handy method to our trait:</p>
<pre><code class="language-rust noplaypen">// Creates a new entity and attaches it to the given parent.
fn attach_new(&amp;mut self, parent: EntityId) -&gt; EntityId;`
</code></pre>
<pre><code class="language-rust noplaypen">fn attach_new(&amp;mut self, parent: EntityId) -&gt; EntityId {
    let id = self.0.add_entity((), ());
    self.attach(id, parent);
    id
}
</code></pre>
<p>And lastly a simple usage example:</p>
<pre><code class="language-rust noplaypen">let world = World::new();

let mut hierarchy = world.borrow::&lt;(EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;)&gt;().unwrap();

let root1 = hierarchy.0.add_entity((), ());
let root2 = hierarchy.0.add_entity((), ());

let e1 = hierarchy.attach_new(root1);
let _e2 = hierarchy.attach_new(e1);
let e3 = hierarchy.attach_new(e1);
let _e4 = hierarchy.attach_new(e3);

hierarchy.attach(e3, root2);
</code></pre>
<h2><a class="header" href="#traversing-the-hierarchy" id="traversing-the-hierarchy">Traversing the hierarchy</a></h2>
<p>There are different ways the hierarchy can be queried.</p>
<p>For example, we may want to know the parent of a given entity. Doing this is simply done by inspecting its child component - if there is one.</p>
<p>However, sometimes you might need</p>
<ul>
<li>all children,</li>
<li>all ancestors,</li>
<li>or all descendants of a given entity.</li>
</ul>
<p>A perfect use case for iterators! An iterator has to implement the <code>next</code> method from the <code>Iterator</code> trait.</p>
<p>We start with a <code>ChildrenIter</code>, which is pretty straightforward:</p>
<pre><code class="language-rust noplaypen">struct ChildrenIter&lt;C&gt; {
    get_child: C,
    cursor: (EntityId, usize),
}

impl&lt;'a, C&gt; Iterator for ChildrenIter&lt;C&gt;
where
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.cursor.1 &gt; 0 {
            self.cursor.1 -= 1;
            let ret = self.cursor.0;
            self.cursor.0 = self.get_child.get(self.cursor.0).unwrap().next;
            Some(ret)
        } else {
            None
        }
    }
}
</code></pre>
<p>Note that we don't implement <code>Iterator</code> for <code>ViewMut&lt;Child&gt;</code> directly, but for a type that implements the <code>GetComponent</code> trait. This way, our iterator can be used with <code>View</code> as well as <code>ViewMut</code>.</p>
<p>The next one is the <code>AncestorIter</code>:</p>
<pre><code class="language-rust noplaypen">struct AncestorIter&lt;C&gt; {
    get_child: C,
    cursor: EntityId,
}

impl&lt;'a, C&gt; Iterator for AncestorIter&lt;C&gt;
where
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.get_child.get(self.cursor).ok().map(|child| {
            self.cursor = child.parent;
            child.parent
        })
    }
}
</code></pre>
<p>Easy.</p>
<p><code>DescendantIter</code> will be a bit more complicated. We choose to implement a depth-first variant using recursion.</p>
<p>It is based on the code for the <code>ChildrenIter</code> but comes with an additional stack to keep track of the current level the cursor is in:</p>
<ul>
<li>Push a new level to the stack if we encounter a <code>Parent</code> component.</li>
<li>Pop the last level from the stack whenever we run out of siblings, then carry on where we left off.</li>
</ul>
<pre><code class="language-rust noplaypen">struct DescendantsIter&lt;P, C&gt; {
    get_parent: P,
    get_child: C,
    cursors: Vec&lt;(EntityId, usize)&gt;,
}

impl&lt;'a, P, C&gt; Iterator for DescendantsIter&lt;P, C&gt;
where
    P: Get&lt;Out = &amp;'a Parent&gt; + Copy,
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    type Item = EntityId;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if let Some(cursor) = self.cursors.last_mut() {
            if cursor.1 &gt; 0 {
                cursor.1 -= 1;
                let ret = cursor.0;
                cursor.0 = self.get_child.get(cursor.0).unwrap().next;
                if let Ok(parent) = self.get_parent.get(ret) {
                    self.cursors.push((parent.first_child, parent.num_children));
                }
                Some(ret)
            } else {
                self.cursors.pop();
                self.next()
            }
        } else {
            None
        }
    }
}
</code></pre>
<p>What we still need to do is to implement a simple trait with methods that return nicely initialized <code>*Iter</code> structs for us:</p>
<pre><code class="language-rust noplaypen">trait HierarchyIter&lt;'a, P, C&gt; {
    fn ancestors(&amp;self, id: EntityId) -&gt; AncestorIter&lt;C&gt;;
    fn children(&amp;self, id: EntityId) -&gt; ChildrenIter&lt;C&gt;;
    fn descendants(&amp;self, id: EntityId) -&gt; DescendantsIter&lt;P, C&gt;;
}

impl&lt;'a, P, C&gt; HierarchyIter&lt;'a, P, C&gt; for (P, C)
where
    P: Get&lt;Out = &amp;'a Parent&gt; + Copy,
    C: Get&lt;Out = &amp;'a Child&gt; + Copy,
{
    fn ancestors(&amp;self, id: EntityId) -&gt; AncestorIter&lt;C&gt; {
        let (_, children) = self;

        AncestorIter {
            get_child: *children,
            cursor: id,
        }
    }

    fn children(&amp;self, id: EntityId) -&gt; ChildrenIter&lt;C&gt; {
        let (parents, children) = self;

        ChildrenIter {
            get_child: *children,
            cursor: parents
                .get(id)
                .map_or((id, 0), |parent| (parent.first_child, parent.num_children)),
        }
    }

    fn descendants(&amp;self, id: EntityId) -&gt; DescendantsIter&lt;P, C&gt; {
        let (parents, children) = self;

        DescendantsIter {
            get_parent: *parents,
            get_child: *children,
            cursors: parents.get(id).map_or_else(
                |_| Vec::new(),
                |parent| vec![(parent.first_child, parent.num_children)],
            ),
        }
    }
}
</code></pre>
<p>Cool. Let's extend the former usage example into a little test.</p>
<pre><code class="language-rust noplaypen">#[test]
fn test_hierarchy() {
    let world = World::new();

    let mut hierarchy = world.borrow::&lt;(EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;)&gt;().unwrap();

    let root1 = hierarchy.0.add_entity((), ());
    let root2 = hierarchy.0.add_entity((), ());

    let e1 = hierarchy.attach_new(root1);
    let e2 = hierarchy.attach_new(e1);
    let e3 = hierarchy.attach_new(e1);
    let e4 = hierarchy.attach_new(e3);

    hierarchy.attach(e3, root2);

    let e5 = hierarchy.attach_new(e3);

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(e3)
        .eq([e4, e5].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .ancestors(e4)
        .eq([e3, root2].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .descendants(root1)
        .eq([e1, e2].iter().cloned()));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .descendants(root2)
        .eq([e3, e4, e5].iter().cloned()));
}
</code></pre>
<h2><a class="header" href="#removing-entities-from-the-hierarchy" id="removing-entities-from-the-hierarchy">Removing entities from the hierarchy</a></h2>
<p>Removing an entity from the hierarchy means removing its <code>Parent</code> and <code>Child</code> components.</p>
<p>To remove an entity's <code>Child</code> component, we can simply reuse <code>detach</code>. Removing its <code>Parent</code> component must be done with caution. This entity's children now become orphans  we have to detach them as well.</p>
<p>Both methods can be added to our <code>Hierarchy</code> trait:</p>
<pre><code class="language-rust noplaypen">fn remove(&amp;mut self, id: EntityId) {
    self.detach(id);

    let children = (&amp;self.1, &amp;self.2).children(id).collect::&lt;Vec&lt;_&gt;&gt;();
    for child_id in children {
        self.detach(child_id);
    }
    self.1.remove(id);
}
</code></pre>
<p>A method that removes a whole subtree is easy to write by making use of recursion again:</p>
<pre><code class="language-rust noplaypen">fn remove_all(&amp;mut self, id: EntityId) {
    let (_, parents, children) = self;

    for child_id in (&amp;*parents, &amp;*children).children(id).collect::&lt;Vec&lt;_&gt;&gt;() {
        self.remove_all(child_id);
    }
    self.remove(id);
}
</code></pre>
<p>That's it! We can now add the following code to the end of our test from the last chapter:</p>
<pre><code class="language-rust noplaypen">hierarchy.detach(e1);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(root1).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).ancestors(e1).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).children(e1).eq([e2].iter().cloned()));

hierarchy.remove(e1);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).children(e1).eq(None));

hierarchy.remove_all(root2);

assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(root2).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).descendants(e3).eq(None));
assert!((&amp;hierarchy.1, &amp;hierarchy.2).ancestors(e5).eq(None));
</code></pre>
<h2><a class="header" href="#sorting" id="sorting">Sorting</a></h2>
<p>The order between siblings may or may not play a role in your project.</p>
<p>However, a simple sorting for children can be done in two steps:</p>
<ul>
<li>Collect all children into a <code>Vec</code> and sort it.</li>
<li>Adjust the linking in the <code>Child</code> components according to the sorted list.</li>
</ul>
<p>We can add this method to the <code>Hierarchy</code> trait:</p>
<pre><code class="language-rust noplaypen">fn sort_children_by&lt;F&gt;(&amp;mut self, id: EntityId, compare: F)
where
    F: FnMut(&amp;EntityId, &amp;EntityId) -&gt; std::cmp::Ordering,
{
    let (_, parents, children_storage) = self;

    let mut children = (&amp;*parents, &amp;*children_storage)
        .children(id)
        .collect::&lt;Vec&lt;EntityId&gt;&gt;();
    if children.len() &gt; 1 {
        children.sort_by(compare);
        // set first_child in Parent component
        parents[id].first_child = children[0];
        // loop through children and relink them
        for i in 0..children.len() - 1 {
            children_storage[children[i]].next = children[i + 1];
            children_storage[children[i + 1]].prev = children[i];
        }
        children_storage[children[0]].prev = *children.last().unwrap();
        children_storage[*children.last().unwrap()].next = children[0];
    }
}
</code></pre>
<p>Again a small test demonstrates the usage:</p>
<pre><code class="language-rust noplaypen">#[test]
fn test_sorting() {
    let world = World::new();

    let (mut hierarchy, mut usizes) = world.borrow::&lt;(
        (EntitiesViewMut, ViewMut&lt;Parent&gt;, ViewMut&lt;Child&gt;),
        ViewMut&lt;usize&gt;,
    )&gt;().unwrap();
    
    let root = hierarchy.0.add_entity((), ());

    let e0 = hierarchy.attach_new(root);
    let e1 = hierarchy.attach_new(root);
    let e2 = hierarchy.attach_new(root);
    let e3 = hierarchy.attach_new(root);
    let e4 = hierarchy.attach_new(root);

    hierarchy.0.add_component(e0, &amp;mut usizes, 7);
    hierarchy.0.add_component(e1, &amp;mut usizes, 5);
    hierarchy.0.add_component(e2, &amp;mut usizes, 6);
    hierarchy.0.add_component(e3, &amp;mut usizes, 1);
    hierarchy.0.add_component(e4, &amp;mut usizes, 3);

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(root)
        .eq([e0, e1, e2, e3, e4].iter().cloned()));

    hierarchy.sort_children_by(root, |a, b| usizes[*a].cmp(&amp;usizes[*b]));

    assert!((&amp;hierarchy.1, &amp;hierarchy.2)
        .children(root)
        .eq([e3, e4, e1, e2, e0].iter().cloned()));
}
</code></pre>
<h2><a class="header" href="#do-it-yourself" id="do-it-yourself">Do it yourself!</a></h2>
<p>We recommend that you build your own hierarchy system fitted to your specific needs. In deviation of the above code examples you may want:</p>
<ul>
<li>a single hierarchy component instead of two,</li>
<li>breadth-first instead of depth-first traversal,</li>
<li>different sorting methods,</li>
<li>etc.</li>
</ul>
<h2><a class="header" href="#further-reading" id="further-reading">Further reading</a></h2>
<p>These notes are based on ideas presented in a highly recommended article by skypjack: <a href="https://skypjack.github.io/2019-06-25-ecs-baf-part-4/">ECS back and forth</a>.</p>
<p>if you're working with <a href="https://github.com/seed-rs/seed">Seed</a>, @MartinKavik ported the bunny demo to it. You can find the source <a href="https://github.com/seed-rs/seed/tree/master/examples/bunnies">here</a>.</p>
<p>0.4 comes with a few big changes, this chapter aims to facilitate the transition.</p>
<h2><a class="header" href="#imports" id="imports">Imports</a></h2>
<p>Let's start small, prelude and internal no longer exist, you just have to replace all <code>shipyard::prelude</code> and <code>shipyard::internal</code> by <code>shipyard</code>.</p>
<h2><a class="header" href="#systems-1" id="systems-1">Systems</a></h2>
<p>Following <a href="https://github.com/leudz/shipyard/issues/75">an issue</a> opened by <a href="https://github.com/cart">@cart</a>, systems will become functions instead of an instance of the <code>System</code> trait.</p>
<p>To make this work, borrowing is now done with the actual types you get when you borrow a storage instead of using references.</p>
<p>In 0.3:</p>
<pre><code class="language-rust noplaypen">struct MySystem;
impl&lt;'sys&gt; System&lt;'sys&gt; for MySystem {
    type Data = (
        EntitiesMut,
        &amp;mut usize,
    );
    fn run((mut entities, mut usizes): &lt;Self::Data as SystemData&lt;'sys&gt;&gt;::View) {}
}

// or with the macro

#[system(MySystem)]
fn run(mut entities: &amp;mut Entities, mut usizes: &amp;mut usize) {}
</code></pre>
<p>In 0.4:</p>
<pre><code class="language-rust noplaypen">fn my_system(mut entities: EntitiesViewMut, mut usizes: ViewMut&lt;usize&gt;) {}
</code></pre>
<p>This change also affects <code>run</code> and <code>borrow</code>.<br />
<code>World::run_system</code> is no longer needed and you can run systems with <code>run</code> directly.</p>
<pre><code class="language-rust noplaypen">world.run(my_system);

// and closures still work

world.run(|mut entities: EntitiesViewMut, mut usizes: ViewMut&lt;usize&gt;| {});
</code></pre>
<p><code>run</code> has the same return type as the system or closure and it doesn't require any tuple most of the time.</p>
<p>Here's the complete list:</p>
<table><thead><tr><th align="center">0.3</th><th align="center">0.4</th></tr></thead><tbody>
<tr><td align="center"><code>AllStorages</code> / <code>&amp;mut AllStorages</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.AllStoragesViewMut.html"><code>AllStoragesViewMut</code></a></td></tr>
<tr><td align="center"><code>Entities</code> / <code>&amp;Entities</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesView.html"><code>EntitiesView</code></a></td></tr>
<tr><td align="center"><code>EntitiesMut</code> / <code>&amp;mut Entities</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.EntitiesViewMut.html"><code>EntitiesViewMut</code></a></td></tr>
<tr><td align="center"><code>&amp;T</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.View.html"><code>View&lt;T&gt;</code></a></td></tr>
<tr><td align="center"><code>&amp;mut T</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.ViewMut.html"><code>ViewMut&lt;T&gt;</code></a></td></tr>
<tr><td align="center"><code>ThreadPool</code> / <code>&amp;ThreadPool</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.ThreadPoolView.html"><code>ThreadPoolView</code></a></td></tr>
<tr><td align="center"><code>Unique&lt;&amp;T&gt;</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueView.html"><code>UniqueView&lt;T&gt;</code></a></td></tr>
<tr><td align="center"><code>Unique&lt;&amp;mut T&gt;</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.UniqueViewMut.html"><code>UniqueViewMut&lt;T&gt;</code></a></td></tr>
<tr><td align="center"><code>NonSend&lt;&amp;T&gt;</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;View&lt;T&gt;&gt;</code></a></td></tr>
<tr><td align="center"><code>NonSend&lt;&amp;mut T&gt;</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;ViewMut&lt;T&gt;&gt;</code></a></td></tr>
<tr><td align="center"><code>Unique&lt;NonSend&lt;&amp;T&gt;&gt;</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;UniqueView&lt;T&gt;&gt;</code></a></td></tr>
<tr><td align="center"><code>Unique&lt;NonSend&lt;&amp;mut T&gt;&gt;</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSend.html"><code>NonSend&lt;UniqueViewMut&lt;T&gt;&gt;</code></a></td></tr>
<tr><td align="center"><code>FakeBorrow&lt;T&gt;</code></td><td align="center"><a href="https://docs.rs/shipyard/latest/shipyard/struct.FakeBorrow.html"><code>FakeBorrow&lt;T&gt;</code></a></td></tr>
</tbody></table>
<p><a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSync.html"><code>NonSync</code></a> and <a href="https://docs.rs/shipyard/latest/shipyard/struct.NonSendSync.html"><code>NonSendSync</code></a> follow the same pattern as <code>NonSend</code>.</p>
<h2><a class="header" href="#macro" id="macro">Macro</a></h2>
<p>The system proc macro doesn't exist anymore. With the new system design the advantage it provides are not great enough to justify it.</p>
<h2><a class="header" href="#workloads-1" id="workloads-1">Workloads</a></h2>
<h3><a class="header" href="#the-ugly" id="the-ugly">The ugly</a></h3>
<p>Workloads are the only one suffering a downgrade. You'll have to give all systems twice to the function plus a few things.</p>
<p>In 0.3:</p>
<pre><code class="language-rust noplaypen">world.add_workload&lt;(Sys1, Sys2), _&gt;(&quot;Workload1&quot;);
</code></pre>
<p>In 0.4:</p>
<pre><code class="language-rust noplaypen">world
    .add_workload(&quot;Workload1&quot;)
    .with_system((
        |world: &amp;World| world.try_run(sys1),
        sys1
    ))
    .with_system((
        |world: &amp;World| world.try_run(sys2),
        sys2
    ))
    .build();

// with a macro

world
    .add_workload(&quot;Workload1&quot;)
    .with_system(system!(sys1))
    .with_system(system!(sys2))
    .build();
</code></pre>
<p> The two arguments are wrapped in a tuple.</p>
<p>This repetition will disappear someday but I don't expect it to be soon.<br />
You don't have to use a closure, any function with <code>&amp;World</code> as argument and returning <code>Result&lt;(), shipyard::error::Run&gt;</code> are valid.<br />
It's very important to pass the same function twice, the workload might always error if this isn't the case.</p>
<h3><a class="header" href="#the-good" id="the-good">The good</a></h3>
<p>Workloads don't come with only a downgrade. You can now return errors from systems inside workloads.</p>
<pre><code class="language-rust noplaypen">#[derive(Debug)]
struct TerribleError;

impl Display for TerribleError {
    fn fmt(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), core::fmt::Error&gt; {
        Debug::fmt(self, fmt)
    }
}
impl Error for TerribleError {}

fn my_sys(mut entities: EntitiesViewMut) -&gt; Result&lt;(), TerribleError&gt; {
    Err(TerribleError)
}

fn main() {
    use shipyard::error::{Run, RunWorkload};

    let world = World::new();
    world
        .add_workload(&quot;May fail&quot;)
        .with_system((
            |world: &amp;World| world.try_run(my_sys)?.map_err(Run::from_custom),
            my_sys,
        ))
        .build();
    match world.try_run_default().map_err(RunWorkload::custom_error) {
        Err(Some(error)) =&gt; {
            assert!(error.is::&lt;TerribleError&gt;());
        }
        _ =&gt; {}
    }
}
</code></pre>
<p>The error has to be anonymized so you'll get back a <code>Box&lt;dyn Error + Send&gt;</code> with std and a <code>Box&lt;dyn Any + Send&gt;</code> with no_std.<br />
Workloads stop at the first error encountered, just like 0.3.<br />
You can also use the <code>try_system!</code> macro the same way as <code>system!</code>.</p>
<pre><code class="language-rust noplaypen">world
    .add_workload(&quot;May fail&quot;)
    .with_system(try_system!(my_sys))
    .build();
</code></pre>
<p>It'll generate the same code as above.</p>
<h2><a class="header" href="#iterator" id="iterator">Iterator</a></h2>
<p>You can now use <code>std::iter::Iterator</code> and <code>for loop</code> with views without having to call <code>into_iter</code>.<br />
All iteration code from 0.3 will still work.</p>
<pre><code class="language-rust noplaypen">fn my_sys((mut usizes, u32s): (ViewMut&lt;usize&gt;, View&lt;u32&gt;)) {
    for (i, &amp;j) in (&amp;mut usizes, &amp;u32s).iter() {
        *i += j as usize;
    }
}
</code></pre>
<h2><a class="header" href="#get" id="get">Get</a></h2>
<p>The <code>GetComponent</code> trait has been renamed <code>Get</code>.</p>
<p>What follows is only true for 0.4. 0.5 went back to <code>get</code> returning a <code>Result</code>.<br />
<code>Get::get</code> has been renamed <code>try_get</code> and a new <code>get</code> method has been added to unwrap errors.</p>
<p>If you used <code>get</code> followed by <code>unwrap</code>, you can simply remove the <code>unwrap</code>.<br />
If you used another error handling method you'll have to replace <code>get</code> by <code>try_get</code>.</p>
<h1><a class="header" href="#pilgrimage" id="pilgrimage">Pilgrimage</a></h1>
<p>Links and information not directly related to shipyard.</p>
<h1><a class="header" href="#different-types-of-ecs" id="different-types-of-ecs">Different Types of ECS</a></h1>
<p>ECS is a pattern and there's no right or wrong way to implement it, even the pattern doesn't have a clear definition.</p>
<p>Shipyard is a <code>SparseSet</code> based ECS, so is <a href="https://github.com/skypjack/entt">EnTT</a> but there are multiple other implementations, here's a few ones:</p>
<h3><a class="header" href="#archetypes" id="archetypes">Archetypes</a></h3>
<p>Let's start with the most popular one, thanks to Unity.</p>
<p>This implementation groups entities and their components based on which one they have. For example all entities with a <code>usize</code> and <code>u32</code> components will be stored together in memory.</p>
<p>When an entity gains or loses a component it moves from an archetype to another.</p>
<p><a href="https://unity.com/dots">Unity's dots</a>, <a href="https://github.com/SanderMertens/flecs/">Flecs</a>, <a href="https://github.com/TomGillen/legion">Legion</a> and <a href="https://github.com/Ralith/hecs">Hecs</a> are implemented using archetypes.</p>
<h3><a class="header" href="#bitset" id="bitset">Bitset</a></h3>
<p>This is how <a href="https://github.com/amethyst/specs">Specs</a> is implemented.</p>
<p>Each component has a storage and a bitset, when an entity has a component the bit at its index is set.</p>
<p>Iterating becomes a bitsets iteration, we <code>or</code> them which yields the entities with all required components.</p>
<h3><a class="header" href="#option" id="option">Option</a></h3>
<p>A simple ECS implementation can be made with <code>Option</code>, each component has a <code>Vec&lt;Option&lt;T&gt;&gt;</code> storage.</p>
<p>The components default to <code>None</code>, when we add a component it switches to <code>Some</code> at the entity's index.</p>
<p>When iterating we simply have to go through all requested storages and check if the components are <code>Some</code>.</p>
<h1><a class="header" href="#more-resources" id="more-resources">More Resources</a></h1>
<p><a href="https://skypjack.github.io/2019-03-21-ecs-baf-part-2-insights/">Packs</a>, the whole series is a good read<br />
<a href="https://www.youtube.com/watch?v=W3aieHjyNvw">Timothy Ford's GDC talk on ECS usage in Overwatch</a><br />
<a href="https://www.youtube.com/watch?v=aKLntZcp27M">Catherine West's closing keynote on using the ECS pattern in Rust</a><br />
<a href="https://github.com/SanderMertens/ecs-faq">Sander Mertens's ECS FAQ</a><br />
<a href="https://www.richardlord.net/blog/ecs/finite-state-machines-with-ash.html">FSM in ECS</a>
<a href="https://github.com/abulka/todomvc-ecs">Todo MVC using ECS</a></p>
<h1><a class="header" href="#contributors" id="contributors">Contributors</a></h1>
<p><a href="https://github.com/dakom">dakom - David Komer</a><br />
<a href="https://github.com/eldyer">eldyer</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
